
import java.util.*;

/**
 * Generated by Navid Vaziri
 */
public class BFS {
    private HashMap<Integer,Node> nodes=new HashMap<Integer,Node>();
    static int row=10;
    static int column=10;
    public static class Node{
        LinkedList<Node> adjacents=new LinkedList<Node>();
        int id;
        public Node(int id){
            this.id=id;
        }
    }

    public Node getNode(int id){
        return nodes.get(id);
    }

    public void addNode(int id, Node node){
        nodes.put(id,node);
    }

    public void addNode(Node node){
        nodes.put(node.id,node);
    }

    public void addEdge(int source, int destination){
        Node s=getNode(source);
        Node d=getNode(destination);
        s.adjacents.add(d);
    }

    public void BFS(int id){
        Queue<Integer> queue=new LinkedList<Integer>();
        queue.add(id);
        Set<Integer> visited=new HashSet<Integer>();
        visited.add(id);
        while(!queue.isEmpty()){
            id=queue.poll();
            Node node=getNode(id);
            System.out.print(id+", ");
            LinkedList<Node> adjacents=node.adjacents;
            for (Node adjacent:adjacents) {
                if(!visited.contains(adjacent.id)){
                    queue.add(adjacent.id);
                    visited.add(adjacent.id);
                }
            }
        }
    }

    public boolean hasPathBFS(int id, int destination){
        Queue<Integer> queue=new LinkedList<Integer>();
        queue.add(id);
        Set<Integer> visited=new HashSet<Integer>();
        visited.add(id);
        while(!queue.isEmpty()){
            id=queue.poll();
            Node node=getNode(id);

            if(id==destination){
                return true;
            }
            LinkedList<Node> adjacents=node.adjacents;
            for (Node adjacent:adjacents) {
                if(!visited.contains(adjacent.id)){
                    queue.add(adjacent.id);
                    visited.add(adjacent.id);
                }
            }
        }
        return false;
    }

    public int[] shortestPathBFS(int id){
        Queue<Integer> queue=new LinkedList<Integer>();
        queue.add(id);
        int[] visited=new int[nodes.size()];
        Arrays.fill(visited,-1);
        visited[id]=0;
        while(!queue.isEmpty()){
            id=queue.poll();
            Node node=getNode(id);
            System.out.print(id+":"+visited[id]+", ");
            LinkedList<Node> adjacents=node.adjacents;
            for (Node adjacent:adjacents) {
                if(visited[adjacent.id]==-1){
                    queue.add(adjacent.id);
                    visited[adjacent.id]=visited[id]+1;
                }
            }
        }
        return visited;
    }

    public int shortestPathBFS(int id, int destination){
        Queue<Integer> queue=new LinkedList<Integer>();
        queue.add(id);
        int[] visited=new int[nodes.size()];
        Arrays.fill(visited,-1);
        visited[id]=0;
        while(!queue.isEmpty()){
            id=queue.poll();
            Node node=getNode(id);
            if(id==destination){
                return visited[id];
            }
            LinkedList<Node> adjacents=node.adjacents;
            for (Node adjacent:adjacents) {
                if(visited[adjacent.id]==-1){
                    queue.add(adjacent.id);
                    visited[adjacent.id]=visited[id]+1;
                }
            }
        }
        return -1;
    }

    public String shortestPathStringBFS(int id, int destination){
        Queue<Integer> queue=new LinkedList<Integer>();
        queue.add(id);
        String[] visited=new String[nodes.size()];
        visited[id]=String.valueOf(id);
        while(!queue.isEmpty()){
            id=queue.poll();
            Node node=getNode(id);
            if(id==destination){
                return visited[id];
            }
            LinkedList<Node> adjacents=node.adjacents;
            for (Node adjacent:adjacents) {
                if(visited[adjacent.id]==null){
                    queue.add(adjacent.id);
                    visited[adjacent.id]=visited[id]+","+adjacent.id;
                }
            }
        }
        return null;
    }

    public void DFS(Node node,boolean[] visited){
        visited[node.id]=true;
        System.out.print(node.id+", ");
        Iterator<Node> it=node.adjacents.iterator();
        while(it.hasNext()){
            Node child=it.next();
            if(!visited[child.id]){
                DFS(child,visited);
            }
        }
    }

    public static void main(String args[])
    {
        BFS g = new BFS();
        g.addNode(0,new Node(0));
        g.addNode(1,new Node(1));
        g.addNode(2,new Node(2));
        g.addNode(3,new Node(3));

        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        //
        //g.addEdge(1, 0);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        int mat[][] = {
            { 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 },
            { 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 },
            { 0, 0, 1, 0, 1, 1, 1, 0, 0, 1 },
            { 1, 0, 1, 1, 1, 0, 1, 1, 0, 1 },
            { 0, 0, 0, 1, 0, 0, 0, 1, 0, 1 },
            { 1, 0, 1, 1, 1, 0, 0, 1, 1, 0 },
            { 0, 0, 0, 0, 1, 0, 0, 1, 0, 1 },
            { 0, 1, 1, 1, 1, 1, 1, 1, 0, 0 },
            { 1, 1, 1, 1, 1, 0, 0, 1, 1, 1 },
            { 0, 0, 1, 0, 0, 1, 1, 0, 0, 1 },
        };

        System.out.println("Following is Breadth First Traversal ");
        g.BFS(2);

        System.out.println();
        System.out.println(g.hasPathBFS(2,3));

        g.shortestPathBFS(1);

        System.out.println();
        System.out.println(g.shortestPathBFS(1,0));

        System.out.println(g.shortestPathStringBFS(1,0));

        g.DFS(g.nodes.get(2),new boolean[4]);

        System.out.println();
        System.out.println(matrixShortestPath(mat,0,0,7,5));
    }

    public static String matrixShortestPath(int[][] matrix, int i, int j, int x, int y){
        Queue<MNode> queue=new LinkedList<MNode>();
        String[][] visited=new String[row][column];
        MNode node=new MNode(i,j,0);
        queue.add(node);
        visited[i][j]=String.valueOf(i)+String.valueOf(j);
        int[] rows={-1,1,0,0};
        int[] columns={0,0,-1,1};
        while(!queue.isEmpty()){
            node=queue.poll();
            if(node.column==y && node.row==x){
                return visited[x][y];
            }
            for (int a=0;a<4;a++){
               if(isValid(node.row+rows[a], node.column+columns[a], matrix)){
                   MNode child=new MNode(node.row+rows[a],node.column+columns[a],node.dist+1);
                   queue.add(child);
                   visited[child.row][child.column]=visited[node.row][node.column]+","+String.valueOf(child.row)+String.valueOf(child.column);
               }
            }
        }
        return null;
    }

    public static boolean isValid(int i, int j, int[][] matrix){

        if(i<row && j<column && i>-1 && j>-1 && matrix[i][j]==1){
            return true;
        }
        return false;
    }
}

class MNode{
    int row,column,dist;
    public MNode(int row, int column, int dist){
        this.row=row;
        this.column=column;
        this.dist=dist;
    }
}
